#include "dynasm/dasm_arm64.h"

|.arch arm64
|.actionlist ej_compile_actionlist
|.section code
|.globals GLOB_

static void emit(Dst_DECL, uint64_t* op) {
  | .macro movq, Xn, imm
  |   movz    Xn, #(imm)&0xffff
  |   movk    Xn, #(imm>>16)&0xffff, lsl #16
  |   movk    Xn, #(imm>>32)&0xffff, lsl #32
  |   movk    Xn, #(imm>>48)&0xffff, lsl #48
  | .endmacro
  | .macro callop_push
  |   str     x30, [sp, #-16]!
  |   movq    x1, *op
  |   blr     x1
  |   ldr     x30, [sp], #16
  |   str     d0, [sp, #-16]!
  | .endmacro
  | .macro callop_store, adj
  |   str     x30, [sp, #-16]!
  |   movq    x1, *op
  |   blr     x1
  |   ldr     x30, [sp], #16
  |   add     sp, sp, #(16 * adj)
  |   str     d0, [sp]
  | .endmacro
  | .macro loadargs1
  |   ldr     d0, [sp]
  | .endmacro
  | .macro loadargs2
  |   ldr     d0, [sp, #(16 * 1)]
  |   ldr     d1, [sp, #(16 * 0)]
  | .endmacro
  | .macro loadargs3
  |   ldr     d0, [sp, #(16 * 2)]
  |   ldr     d1, [sp, #(16 * 1)]
  |   ldr     d2, [sp, #(16 * 0)]
  | .endmacro
  | .macro loadargs4
  |   ldr     d0, [sp, #(16 * 3)]
  |   ldr     d1, [sp, #(16 * 2)]
  |   ldr     d2, [sp, #(16 * 1)]
  |   ldr     d3, [sp, #(16 * 0)]
  | .endmacro
  | .macro loadargs5
  |   ldr     d0, [sp, #(16 * 4)]
  |   ldr     d1, [sp, #(16 * 3)]
  |   ldr     d2, [sp, #(16 * 2)]
  |   ldr     d3, [sp, #(16 * 1)]
  |   ldr     d4, [sp, #(16 * 0)]
  | .endmacro
  | .macro loadargs6
  |   ldr     d0, [sp, #(16 * 5)]
  |   ldr     d1, [sp, #(16 * 4)]
  |   ldr     d2, [sp, #(16 * 3)]
  |   ldr     d3, [sp, #(16 * 2)]
  |   ldr     d4, [sp, #(16 * 1)]
  |   ldr     d5, [sp, #(16 * 0)]
  | .endmacro
  | .macro loadargs7
  |   ldr     d0, [sp, #(16 * 6)]
  |   ldr     d1, [sp, #(16 * 5)]
  |   ldr     d2, [sp, #(16 * 4)]
  |   ldr     d3, [sp, #(16 * 3)]
  |   ldr     d4, [sp, #(16 * 2)]
  |   ldr     d5, [sp, #(16 * 1)]
  |   ldr     d6, [sp, #(16 * 0)]
  | .endmacro
  | .macro logic, op
  |   ldr     d1, [sp], #16
  |   ldr     d0, [sp]
  |   fcmp    d0, d1
  |   cset    w0, op
  |   ucvtf   d0, w0
  |   str     d0, [sp]
  | .endmacro
  | .macro arithm, op
  |   ldr     d1, [sp], #16
  |   ldr     d0, [sp]
  |   op      d0, d0, d1
  |   str     d0, [sp]
  | .endmacro
  while (1) {
    switch (*op) {
      case OP_pos:
        | .nop
        break;
      case OP_neg:
        | ldr     d0, [sp]
        | fneg    d0, d0
        | str     d0, [sp]
        break;
      case OP_add:
        | arithm  fadd
        break;
      case OP_sub:
        | arithm  fsub
        break;
      case OP_mul:
        | arithm  fmul
        break;
      case OP_div:
        | arithm  fdiv
        break;
      case OP_var:
        op++;
        | movq    x1, *op
        | ldr     x0, [x1]
        | fmov    d0, x0
        | str     d0, [sp, #-16]!
        break;
      case OP_con:
        op++;
        | movq    x0, *op
        | fmov    d0, x0
        | str     d0, [sp, #-16]!
        break;
      case OP_ret:
        | ldr     d0, [sp], #16
        | ret
        return;
      case OP_clo0:
        op++;
        | movq    x0, *op
      case OP_fun0:
        op++;
        | callop_push
        break;
      case OP_clo1:
        op++;
        | movq    x0, *op
      case OP_fun1:
        op++;
        | loadargs1
        | callop_store 0
        break;
      case OP_clo2:
        op++;
        | movq    x0, *op
      case OP_fun2:
        op++;
        | loadargs2
        | callop_store 1
        break;
      case OP_clo3:
        op++;
        | movq    x0, *op
      case OP_fun3:
        op++;
        | loadargs3
        | callop_store 2
        break;
      case OP_clo4:
        op++;
        | movq    x0, *op
      case OP_fun4:
        op++;
        | loadargs4
        | callop_store 3
        break;
      case OP_clo5:
        op++;
        | movq    x0, *op
      case OP_fun5:
        op++;
        | loadargs5
        | callop_store 4
        break;
      case OP_clo6:
        op++;
        | movq    x0, *op
      case OP_fun6:
        op++;
        | loadargs6
        | callop_store 5
        break;
      case OP_clo7:
        op++;
        | movq    x0, *op
      case OP_fun7:
        op++;
        | loadargs7
        | callop_store 6
        break;

      case OP_lt:
        | logic   mi
        break;
      case OP_le:
        | logic   ls
        break;
      case OP_gt:
        | logic   gt
        break;
      case OP_ge:
        | logic   ge
        break;
      case OP_eq:
        | logic   eq
        break;
      case OP_neq:
        | logic   ne
        break;
      case OP_and:
        | ldr     d1, [sp], #16
        | ldr     d0, [sp]
        | fcmp    d0, #0.0
        | cset    w0, ne
        | fcmp    d1, #0.0
        | cset    w1, ne
        | and     w0, w0, w1
        | ucvtf   d0, w0
        | str     d0, [sp]
        break;
      case OP_or:
        | ldr     d1, [sp], #16
        | ldr     d0, [sp]
        | fcmp    d0, #0.0
        | cset    w0, ne
        | fcmp    d1, #0.0
        | cset    w1, ne
        | orr     w0, w0, w1
        | ucvtf   d0, w0
        | str     d0, [sp]
        break;
      case OP_not:
        | ldr     d0, [sp]
        | fcmpe   d0, #0.0
        | cset    w0, eq
        | ucvtf   d0, w0
        | str     d0, [sp]
        break;

      default:
        assert(0);
        __builtin_unreachable();
    }
    
    ++op;
  }
}
